\section{背包模型}

\begin{frame}
  \frametitle{背包模型描述}

  这类问题实际上就是不那么等概率了。于是要根据概率的值域做 dp。还可能需要 NTT 来做加速。

\end{frame}

\begin{frame}
  \frametitle{【洛谷 P4707】重返现世}

  \begin{block}{题目描述}
  有 $n$ 种原料，只需要集齐任意 $k$ 种。每个单位时间，会随机生成一种原料。

  每种原料被生成的概率是不同的，第 $i$ 种原料被生成的概率是 $\frac{p_i}{m}$。

  如果没有这种原料，那么就可以进行收集。求收集到任意 $k$ 种原料的期望时间，答案对 $998244353$ 取模。

  $m\le 10000$。实际数据保证 $1\le p_i$ 且总和为 $m$。

  \end{block}  

\end{frame}

\begin{frame}

  max 转 min 后，集\textbf{齐} k 种（全集 $S$ 获得时间第 $k$ 晚）
  变成得到\textbf{一}种（穷举 $T\subseteq S$ 并分配系数，$T$ 内获得时间第 $1$ 早）。
  需要用到 k-th min-max，会多一个二项式系数。这题第二个部分也就是处理一个二项式求和。
  数学事实是：

  \begin{exampleblock}{几何分布}
    对于一个发生概率为 $p$ 的事件，发生的期望步数为 $1/p$。（根据定义求和然后就是高数习题了）。
  \end{exampleblock}

  处理方法是根据值域 dp（俗称背包问题）（这里所谓值域，观察一下求和式可以想到）。
  转移方程是二项式系数最简单的递推方程。

\end{frame}

\begin{frame}

  \begin{alertblock}{吐槽}

    洛谷题解那里说什么初值很神仙、负负得正，其实完全没那必要。前者其实是因为 min-max 容斥特有的不考虑空集，然而我们 initially 手动处理大小为 1 的集合就行了。后者是有点笨了，硬是要把 $(-1)^{k}$ 项和二项式下面的一部分绑定起来，然而这玩意和 sigma 枚举的下标无关，直接提到求和号外面就好了。
    经过测试本题实质上没有 $p=0$ 的数据。如果有的话已有数据约束其实并不够。
    
  \end{alertblock}

\end{frame}

\begin{frame}
  \frametitle{【ABC331】Collect Them All}

  \begin{block}{题目描述}
  
    盒子中共有 $N$ 张卡片。每张卡片上写有一个介于 $1$ 和 $M$（含端点）之间的整数。
    对于每个 $i = 1,2,\dots,M$，恰有 $C_i$ 张卡片上写有数字 $i$。

    从一个空的笔记本开始，你重复以下操作：
    \begin{itemize}
    \item 随机从盒子中抽取一张卡片，将卡片上的数字记入笔记本，然后将卡片放回盒子中。
    \end{itemize}

    求直到笔记本中至少写齐所有整数 $1$ 到 $M$ 为止，所执行此操作的次数的期望值，并对结果取模 $998244353$。

    $M\le N \le 2\times 10^{5}$。


  \end{block}  

\end{frame}

\begin{frame}

  从式子推导来说简直是上个问题的弱化版。但是上个问题跑了背包就得 $O(nm)$ 了，这题过不去。
  
  这里其实也就是优化一下这个背包，把系数放进 generating function，跑多项式乘法，然后再统计答案。

  当然这里还有一个类似启发式合并的 trick。多项式乘法允许我们在 $(siz_1+siz_2)\log(siz_1+siz_2)$ 合并两个背包，
  
  现在要合理安排合并顺序：即采用一个 priority_queue 维护目前最小的两个背包将它们合并。


  区别于经典的启发式合并的每一步扩大一倍，即，只有小量产生贡献而每次贡献完规模至少扩大一倍。
  这里的分析方式是考虑一个对象合并的遗传链，并把两步合成，看作一组。
  容易发现，一组合并能使规模至少扩大一倍。即这里大量也产生贡献，但是它也能保证每两步扩大一倍。
  
  这里顺便可以复习一下 NTT。为什么要选原根去取代 FFT 的单位根呢？因为要避免 DFT 时重复代入相同的点值，这会导致 DFT 矩阵出现完全相同的两行，从而不满秩，不可逆，无法保证 IDFT 的正确性。

\end{frame}