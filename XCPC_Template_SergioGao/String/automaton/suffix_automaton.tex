\subsection{后缀自动机}

\lstinputlisting{String/automaton/suffix_automaton.cpp}

\subsubsection{备注}

一般来说，和 dag 相关的，是考虑在上面构建字符串。
这个时候 dag 起到一个压缩结点数量的作用。
当两种路径跑完，构建出一个串了，
结果后续能再添加的后缀完全一致，则没必要分别维护。

这种问题里，如果懒得再对 dag 或者 parent 树重新拓扑排序，
那么可以调用代码里 ord 数组的顺序，
即针对每个结点 len 桶排序后的结果来从小往大做，反之同理。

要注意，千万不能以为默认编号蕴含拓扑序。
因为每次增量构造时，是可能增加克隆结点的，
这些结点可能会成为一些已经建好的点的父亲。

\subsubsection{后缀树}

将字符串翻转后，跑 SAM，则 parent 树就是原串的后缀树。

可以这样考虑：parent 树的非克隆结点，对应一个完整的前缀。（对于翻转前字符串，则为完整后缀。）

对于两个非克隆结点的 lca 处的 len，其实就是它们的最长公共后缀。（对于翻转前字符串，则为两个完整后缀的最长公共前缀。）


